
<div class="row">

  <div class="col-md-3">
    
  </div><!--/.col-md-3 -->

  <div class="col-md-9">
    <svg id="graph"></svg>
  </div><!--/.col-md-9 -->

</div><!--/.row -->

<script type="text/javascript">
  
  var w = 1000;
    var h = 600;
    var linkDistance=200;

    var colors = d3.scale.category10();

    // get data as json from back end and put into graph object
    d3.json("/graph/data?map_id=" + "<%=@map.id%>" + "&format=json", function(error, graph) {
      if (error){ 
        console.log("error: " + error + " | graph: " + graph); 
        return;};
 
      var svg = d3.select("body").append("svg").attr({"width":w,"height":h});

      var force = d3.layout.force()
          .nodes(graph.nodes)
          .links(graph.edges)
          .size([w,h])
          .linkDistance([linkDistance])
          .charge([-500])
          .theta(0.1)
          .gravity(0.05)
          .start();

      // any edges with duplicate source and target get an incremented 'linknum'
      for (var i = 0; i < graph.edges.length; i++){
        if ( i != 0 &&
             graph.edges[i].source == graph.edges[i-1].source &&
             graph.edges[i].target == graph.edges[i-1].target){
                  graph.edges[i].linknum = graph.edges[i-1].linknum + 1;
            }
        else {graph.edges[i].linknum = 1;};
      };

      // console log the linknum values
      for (var i = 0; i < graph.edges.length; i++){
        console.log("edge["+i+"] : " + graph.edges[i].linknum + " s: " + graph.edges[i].source.name + " t: " + graph.edges[i].target.name);
      }

      var edges = svg.selectAll("line")
        .data(graph.edges)
        .enter()
        .append("path")
        .attr("id",function(d,i) {return 'edge'+i})
        .attr('marker-end','url(#arrowhead)')
        .attr("fill", "none")
        .style("stroke","#ccc")
        .style("pointer-events", "none");
      
      var nodes = svg.selectAll("circle")
        .data(graph.nodes)
        .enter()
        .append("circle")
        .attr({"r":15})
        .style("fill",function(d,i){return colors(i);})
        .call(force.drag);

      var nodelabels = svg.selectAll(".nodelabel") 
         .data(graph.nodes)
         .enter()
         .append("text")
         .attr({"x":function(d){return d.x;},
                "y":function(d){return d.y;},
                "class":"nodelabel",
                "stroke":"black"})
         .text(function(d){return d.name;});

      var edgepaths = svg.selectAll(".edgepath")
          .data(graph.edges)
          .enter()
          .append('path')
          .attr({'d': function(d) {return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},
                 'class':'edgepath',
                 'fill-opacity':0,
                 'stroke-opacity':0,
                 'fill':'blue',
                 'stroke':'red',
                 'id':function(d,i) {return 'edgepath'+i}})
          .style("pointer-events", "none");

      var edgelabels = svg.selectAll(".edgelabel")
          .data(graph.edges)
          .enter()
          .append('text')
          .style("pointer-events", "none")
          .attr({'class':'edgelabel',
                 'id':function(d,i){return 'edgelabel'+i},
                 'dx':80,
                 'dy':0,
                 'font-size':10,
                 'fill':'#aaa'});

      edgelabels.append('textPath')
          .attr('xlink:href',function(d,i) {return '#edgepath'+i})
          .style("pointer-events", "none")
          .text(function(d,i){return d.type +' '+i});


      svg.append('defs').append('marker')
          .attr({'id':'arrowhead',
                 'viewBox':'-0 -5 10 10',
                 'refX':25,
                 'refY':0,
                 //'markerUnits':'strokeWidth',
                 'orient':'auto',
                 'markerWidth':10,
                 'markerHeight':10,
                 'xoverflow':'visible'})
          .append('svg:path')
              .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
              .attr('fill', '#ccc')
              .attr('stroke','#ccc');

      force.on("tick", function(){

          edges.attr("d", function(d) {
              var dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = (Math.sqrt(dx * dx + dy * dy))-(35*d.linknum);
                  //dr = 100 / d.linknum
              return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
          });

          nodes.attr({"cx":function(d){return d.x;},
                      "cy":function(d){return d.y;}
          });

          nodelabels.attr("x", function(d) { return d.x; }) 
                    .attr("y", function(d) { return d.y; });

          // edgepaths.attr('d', function(d) { var path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;
          //                                    //console.log(d)
          //                                    return path});  

          edgepaths.attr("d", function(d) {
              var dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = (Math.sqrt(dx * dx + dy * dy))-(35*d.linknum);
                  //dr = 100 /d.linknum; 
                  console.log("dr: " + dr + " n: " + d.type);
              return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
          });    

          edgelabels.attr('transform',function(d,i){
              if (d.target.x<d.source.x){
                  bbox = this.getBBox();
                  rx = bbox.x+bbox.width/2;
                  ry = bbox.y+bbox.height/2;
                  return 'rotate(180 '+rx+' '+ry+')';
                  }
              else {
                  return 'rotate(0)';
                  }
          });

          // edgelabels.attr("transform", function(d) {
          //     return "translate(" + (d.source.x + d.target.x) / 2 + "," 
          //     + (d.source.y + d.target.y) / 2 + ")"; });

          }); // close force function call

    }); //close d3.json call

</script>